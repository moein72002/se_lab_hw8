## بخش اول – پیاده‌سازی الگوی Adapter

### زیربخش ۱ – انتخاب نوع Adapter
ما از **Object Adapter** (دامنه شیء) به جای **Class Adapter** (دامنه کلاس) استفاده می‌کنیم. دلیل این کار آن است که استفاده از Object Adapter انعطاف‌پذیری بیشتری را از طریق ترکیب به جای وراثت فراهم می‌کند و به ما اجازه می‌دهد پیاده‌سازی‌های مختلف کتابخانه را بدون نیاز به تغییر در کد کلاینت یا تکیه بر وراثت چندگانه بکار بگیریم.

### زیربخش ۲ – نحوه پیاده‌سازی الگو
1. یک واسط هدف (مانند `GraphAdapterInterface`) تعریف می‌کنیم که کلاس‌های کلاینت برای عملیات مرتبط با گراف به آن وابسته باشند.
2. یک کلاس آداپتر (مثلاً `JungGraphAdapter` یا `JGraphTAdapter`) پیاده‌سازی می‌کنیم که یک نمونه از گراف کتابخانه اصلی را درون خود نگه می‌دارد و متدهای واسط هدف را به فراخوانی‌های آن نمونه تبدیل می‌کند.
3. هر زمان که نیاز به تغییر کتابخانه (از JUNG به JGraphT) داشته باشیم، فقط پیاده‌سازی آداپتر را جایگزین می‌کنیم و واسط هدف برای کلاس‌های کلاینت تغییری نمی‌کند.

---

بخش دوم – تغییر کتابخانه

زیربخش ۱ – گزارش چگونگی تغییر کتابخانه
برای تغییر کتابخانه، کافی است آداپتر مبتنی بر JUNG را با یک آداپتر مبتنی بر JGraphT جایگزین کنیم. به طور مشخص:
- یک کلاس آداپتری ایجاد یا اصلاح می‌کنیم که یک شیء Graph<Integer, String> از کتابخانه JGraphT را در خود جای می‌دهد.
- به جای اینکه از SparseMultigraph<Integer, String> در JUNG استفاده کند. سایر بخش‌های سیستم همچنان از متدهای آداپتر فراخوانی می‌کنند.

زیربخش ۲ – تغییرات ناشی از تغییر کتابخانه از JUNG به JGraphT
1. به‌روزرسانی وابستگی: از وابستگی Maven با نام jgrapht-core استفاده می‌کنیم و در صورت تمایل وابستگی jung-graph-impl را حذف یا غیرفعال می‌کنیم.
2. پیاده‌سازی آداپتر: در آداپتر جدید، یک گراف در JGraphT (مثلاً SimpleGraph<Integer, DefaultEdge>) ایجاد می‌کنیم و متدهای معادل "افزودن گره"، "افزودن یال" و "همسایه‌ها را به دست آوردن" را ارائه می‌دهیم.
3. بدون تغییر در Traversers: کلاس‌های BFS و DFS (مثل BfsGraphTraverser و DfsGraphTraverser) نیازی به تغییر ندارند؛ زیرا از طریق واسط آداپتر با گراف تعامل دارند و مستقیماً به JUNG یا JGraphT وابسته نیستند.
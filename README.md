## بخش اول – پیاده‌سازی الگوی Adapter

### زیربخش ۱ – انتخاب نوع Adapter
ما از **Object Adapter** (دامنه شیء) به جای **Class Adapter** (دامنه کلاس) استفاده می‌کنیم. دلیل این کار آن است که استفاده از Object Adapter انعطاف‌پذیری بیشتری را از طریق ترکیب به جای وراثت فراهم می‌کند و به ما اجازه می‌دهد پیاده‌سازی‌های مختلف کتابخانه را بدون نیاز به تغییر در کد کلاینت یا تکیه بر وراثت چندگانه بکار بگیریم.

### زیربخش ۲ – نحوه پیاده‌سازی الگو
1. یک واسط هدف (مانند `GraphAdapterInterface`) تعریف می‌کنیم که کلاس‌های کلاینت برای عملیات مرتبط با گراف به آن وابسته باشند.
2. یک کلاس آداپتر (مثلاً `JungGraphAdapter` یا `JGraphTAdapter`) پیاده‌سازی می‌کنیم که یک نمونه از گراف کتابخانه اصلی را درون خود نگه می‌دارد و متدهای واسط هدف را به فراخوانی‌های آن نمونه تبدیل می‌کند.
3. هر زمان که نیاز به تغییر کتابخانه (از JUNG به JGraphT) داشته باشیم، فقط پیاده‌سازی آداپتر را جایگزین می‌کنیم و واسط هدف برای کلاس‌های کلاینت تغییری نمی‌کند.

---

بخش دوم – تغییر کتابخانه

زیربخش ۱ – گزارش چگونگی تغییر کتابخانه
برای تغییر کتابخانه، کافی است آداپتر مبتنی بر JUNG را با یک آداپتر مبتنی بر JGraphT جایگزین کنیم. به طور مشخص:
- یک کلاس آداپتری ایجاد یا اصلاح می‌کنیم که یک شیء Graph<Integer, String> از کتابخانه JGraphT را در خود جای می‌دهد.
- به جای اینکه از SparseMultigraph<Integer, String> در JUNG استفاده کند. سایر بخش‌های سیستم همچنان از متدهای آداپتر فراخوانی می‌کنند.

زیربخش ۲ – تغییرات ناشی از تغییر کتابخانه از JUNG به JGraphT
1. به‌روزرسانی وابستگی: از وابستگی Maven با نام jgrapht-core استفاده می‌کنیم و در صورت تمایل وابستگی jung-graph-impl را حذف یا غیرفعال می‌کنیم.
2. پیاده‌سازی آداپتر: در آداپتر جدید، یک گراف در JGraphT (مثلاً SimpleGraph<Integer, DefaultEdge>) ایجاد می‌کنیم و متدهای معادل "افزودن گره"، "افزودن یال" و "همسایه‌ها را به دست آوردن" را ارائه می‌دهیم.
3. بدون تغییر در Traversers: کلاس‌های BFS و DFS (مثل BfsGraphTraverser و DfsGraphTraverser) نیازی به تغییر ندارند؛ زیرا از طریق واسط آداپتر با گراف تعامل دارند و مستقیماً به JUNG یا JGraphT وابسته نیستند.


---

بخش سوم – تحلیل الگوی Strategy

چرا استفاده از این الگو قابل قبول است؟
چون ما می‌خواهیم الگوریتم‌های پیمایش مختلف (BFS، DFS یا الگوریتم‌های دیگر) را بدون نیاز به تغییر کد کلاینت پشتیبانی کنیم. الگوی Strategy امکان کپسوله‌سازی هر روش پیمایش را در کلاس جداگانه فراهم می‌کند و در عین حال همگی یک واسط مشترک را به اشتراک می‌گذارند.

روش تحقق این الگو در سه خط:
1. ابتدا یک واسط استراتژی (Traverser) تعریف می‌کنیم که متدی مثل traverse(startVertex) دارد.
2. سپس کلاس‌های استراتژی پیاده‌ساز (BfsGraphTraverser, DfsGraphTraverser) را می‌سازیم که الگوریتم پیمایش را اجرا می‌کنند.
3. در نهایت، کلاینت (مثلاً کلاس Main) یک شیء از نوع Traverser دارد و فقط متد traverse(...) را فراخوانی می‌کند که در صورت نیاز می‌تواند در زمان اجرا جایگزین شود.
